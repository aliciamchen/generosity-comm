var round = function (num, precision) {
  Number.parseFloat(num.toFixed(precision));
};

var params = {
  beta: argv.beta,
  actions: ["own", "other"],
  comm_weight: argv.comm_weight,
  fairness_cost: argv.fairness_weight,
  condition: argv.condition, // either vary_base_weights or vary_beta
  w_other_values: map(function (x) {
    round(x, 2);
  }, _.range(0, 1, 0.01)),
  n_rounds: 20,
  participants: 100
};

var getOpposite = function (action) {
  return action == "own" ? "other" : "own";
}

var benefits = function (scenario) {
  var scenario_benefits = {
    coffee: {
      own: 3,
      other: 5,
    },
  };
  return scenario_benefits[scenario];
};

var getActionBenefits = function (scenario, action, w_other) {
  if (action == "own") {
    return (
      (1 - w_other) * benefits(scenario)["own"] +
      w_other * benefits(scenario)["other"]
    );
  } else {
    return (
      (1 - w_other) * benefits(scenario)["other"] +
      w_other * benefits(scenario)["own"]
    );
  }
};

var getCumulativeActionBenefits = function (scenario, actions, w_other) {
  return reduce(
    function (a, b) {
      return a + b;
    },
    0,
    map(function (action) {
      return getActionBenefits(scenario, action, w_other);
    }, actions)
  );
}

var getEqualityCost = function(scenario, past_actions, action, equality_cost_weight) {
  var speakerTotalBenefit = getCumulativeActionBenefits(scenario, past_actions, 0) + benefits(scenario)[action];
  var listenerTotalBenefit = getCumulativeActionBenefits(scenario, map(function(a) {return getOpposite(a)}, past_actions), 0) + benefits(scenario)[getOpposite(action)];
  var cost = (speakerTotalBenefit - listenerTotalBenefit) > 0 ? (speakerTotalBenefit - listenerTotalBenefit) : 0;
  return equality_cost_weight * cost;
}


var base_speaker = function (scenario, past_actions, w_other, equality_cost_weight) {
  return Infer({ method: "enumerate" }, function () {
    var action = uniformDraw(params.actions); // "own" or "other", "own" means that the actor is generous

    var getUtility = function (past_actions, action) {
      return (
        // getActionBenefits(scenario, past_actions, w_other) +
        getActionBenefits(scenario, action, w_other) -
        getEqualityCost(scenario, past_actions, action, equality_cost_weight)
      );
    };

    factor(params.beta * getUtility(past_actions, action));
    return action;
  });
};

var base_listener = function (scenario, past_actions, speaker_action, equality_cost_weight) {
  return Infer({ method: "enumerate" }, function () {
    var w_other = uniformDraw(params.w_other_values);
    var getUtility = function () {
      return (
        base_speaker(scenario, past_actions, w_other, equality_cost_weight).score(speaker_action) +
        getCumulativeActionBenefits(scenario, past_actions, w_other)
      );
    };
    factor(getUtility());
    return w_other;
  });
};

var communicative_speaker = function (scenario, past_actions, w_other, equality_cost_weight, comm_weight) {
  return Infer({ method: "enumerate" }, function () {
    var action = uniformDraw(params.actions); // "own" or "other", "own" means that the actor is generous

    var getUtility = function (action) {
      var surprisal = base_listener(scenario, past_actions, action, equality_cost_weight).score(0.5); // communicate equal weights
      return (
        // getCumulativeActionBenefits(scenario, past_actions, w_other) +
        getActionBenefits(scenario, action, w_other) -
        getEqualityCost(scenario, past_actions, action, equality_cost_weight) +
        comm_weight * surprisal
      );
    };

    factor(params.beta * getUtility(action));
    return action;
  });
};

if (params.condition == "vary_beta") {
  // fix speaker's weight on listener's utility; vary beta
  var f = csv.open(
    "./output/vary_beta/" +
      "beta" +
      params.beta +
      "_cw" +
      params.comm_weight.toFixed(1) +
      ".csv"
  );
  csv.writeLine("beta,comm_weight,first_action,p_own,p_other,p_alternation", f);

  csv.writeLine(
    [
      params.beta,
      params.comm_weight,
      "own",
      Math.exp(communicative_speaker("coffee", "own", 0.5).score("own")),
      Math.exp(communicative_speaker("coffee", "own", 0.5).score("other")),
      Math.exp(communicative_speaker("coffee", "own", 0.5).score("other")),
    ].join(","),
    f
  );

  csv.writeLine(
    [
      params.beta,
      params.comm_weight,
      "other",
      Math.exp(communicative_speaker("coffee", "other", 0.5).score("own")),
      Math.exp(communicative_speaker("coffee", "other", 0.5).score("other")),
      Math.exp(communicative_speaker("coffee", "other", 0.5).score("own")),
    ].join(","),
    f
  );

  csv.close(f);
}

if (params.condition == "fairness_comm") {
  // Fairness cost, communication weight
  var f = csv.open(
    "./output/fairness_comm/" +
      "beta" +
      params.beta +
      "_fw" +
      params.fairness_cost.toFixed(2) +
      "_cw" +
      params.comm_weight.toFixed(2) +
      ".csv"
  );
  csv.writeLine("beta,comm_weight,fairness_weight,first_action,p_own,p_other,p_alternation", f);

  csv.writeLine(
    [
      params.beta,
      params.comm_weight,
      params.fairness_cost,
      "own",
      Math.exp(communicative_speaker("coffee", ["own"], 0.5, params.fairness_cost, params.comm_weight).score("own")),
      Math.exp(communicative_speaker("coffee", ["own"], 0.5, params.fairness_cost, params.comm_weight).score("other")),
      Math.exp(communicative_speaker("coffee", ["own"], 0.5, params.fairness_cost, params.comm_weight).score("other")),
    ].join(","),
    f
  );

  csv.writeLine(
    [
      params.beta,
      params.comm_weight,
      params.fairness_cost,
      "other",
      Math.exp(communicative_speaker("coffee", ["other"], 0.5, params.fairness_cost, params.comm_weight).score("own")),
      Math.exp(communicative_speaker("coffee", ["other"], 0.5, params.fairness_cost, params.comm_weight).score("other")),
      Math.exp(communicative_speaker("coffee", ["other"], 0.5, params.fairness_cost, params.comm_weight).score("own")),
    ].join(","),
    f
  );

  csv.close(f);
}

if (params.condition == "vary_base_weights") {
  // vary speaker's weight on listener's utility, and also weight on surprisal
  var f = csv.open(
    "./output/vary_base_weights/" +
      "beta" +
      params.beta +
      "_cw" +
      params.comm_weight.toFixed(1) +
      ".csv"
  );
  csv.writeLine(
    "beta,fairness_weight,comm_weight,first_action,w_other,p_own,p_other,p_alternation",
    f
  );

  map(
    function (w_other) {
      csv.writeLine(
        [
          params.beta,
          params.fairness_cost,
          params.comm_weight,
          "other",
          w_other,
          Math.exp(
            communicative_speaker("coffee", ["other"], w_other, params.fairness_cost, params.comm_weight).score("own")
          ),
          Math.exp(
            communicative_speaker("coffee", ["other"], w_other, params.fairness_cost, params.comm_weight).score("other")
          ),
          Math.exp(
            communicative_speaker("coffee", ["other"], w_other, params.fairness_cost, params.comm_weight).score("own")
          ),
        ].join(","),
        f
      );
    },
    map(function (x) {
      round(x, 2);
    }, _.range(0, 1.1, 0.1))
  );

  map(
    function (w_other) {
      csv.writeLine(
        [
          params.beta,
          params.fairness_cost,
          params.comm_weight,
          "own",
          w_other,
          Math.exp(
            communicative_speaker("coffee", ["own"], w_other, params.fairness_cost, params.comm_weight).score("own")
          ),
          Math.exp(
            communicative_speaker("coffee", ["own"], w_other, params.fairness_cost, params.comm_weight).score("other")
          ),
          Math.exp(
            communicative_speaker("coffee", ["own"], w_other, params.fairness_cost, params.comm_weight).score("other")
          ),
        ].join(","),
        f
      );
    },
    map(function (x) {
      round(x, 2);
    }, _.range(0, 1.1, 0.1))
  );

  csv.close(f);
}


if (params.condition == "vary_base_weights_fairness") {
  // vary speaker's weight on listener's utility, and also weight on fairness
  var f = csv.open(
    "./output/vary_base_weights_fairness/" +
      "beta" +
      params.beta +
      "_fw" +
      params.fairness_cost.toFixed(2) +
      ".csv"
  );
  csv.writeLine(
    "beta,fairness_weight,comm_weight,first_action,w_other,p_own,p_other,p_alternation",
    f
  );

  map(
    function (w_other) {
      csv.writeLine(
        [
          params.beta,
          params.fairness_cost,
          params.comm_weight,
          "other",
          w_other,
          Math.exp(
            communicative_speaker("coffee", ["other"], w_other, params.fairness_cost, params.comm_weight).score("own")
          ),
          Math.exp(
            communicative_speaker("coffee", ["other"], w_other, params.fairness_cost, params.comm_weight).score("other")
          ),
          Math.exp(
            communicative_speaker("coffee", ["other"], w_other, params.fairness_cost, params.comm_weight).score("own")
          ),
        ].join(","),
        f
      );
    },
    map(function (x) {
      round(x, 2);
    }, _.range(0, 1.1, 0.1))
  );

  map(
    function (w_other) {
      csv.writeLine(
        [
          params.beta,
          params.fairness_cost,
          params.comm_weight,
          "own",
          w_other,
          Math.exp(
            communicative_speaker("coffee", ["own"], w_other, params.fairness_cost, params.comm_weight).score("own")
          ),
          Math.exp(
            communicative_speaker("coffee", ["own"], w_other, params.fairness_cost, params.comm_weight).score("other")
          ),
          Math.exp(
            communicative_speaker("coffee", ["own"], w_other, params.fairness_cost, params.comm_weight).score("other")
          ),
        ].join(","),
        f
      );
    },
    map(function (x) {
      round(x, 2);
    }, _.range(0, 1.1, 0.1))
  );

  csv.close(f);
}

if (params.condition == "sequential") {

  var condition_names = ["fairness_only", "comm_only", "fairness_comm", "base"]
  var conditions = {
    "fairness_only": {fairness_cost: 0.5, comm_weight: 0},
    "comm_only": {fairness_cost: 0, comm_weight: 1},
    "fairness_comm": {fairness_cost: 0.5, comm_weight: 1},
    "base": {fairness_cost: 0, comm_weight: 0}
  }

  var run = function (scenario, condition, dataSoFar) {

    var next_action = sample(communicative_speaker(scenario, dataSoFar.actions, 0.5, conditions[condition].fairness_cost, conditions[condition].comm_weight));
    var p_alternation = communicative_speaker(scenario, dataSoFar.actions, 0.5, conditions[condition].fairness_cost, conditions[condition].comm_weight).score(getOpposite(dataSoFar.actions[dataSoFar.actions.length - 1]));
    var newDataSoFar = {
      actions: dataSoFar.actions.concat(next_action),
      p_alternation: dataSoFar.p_alternation.concat(Math.exp(p_alternation)) // TOOD: maybe add p_own and p_other
    };

    if (dataSoFar.actions.length < params.n_rounds) {
      return run(scenario, condition, newDataSoFar);
    } else {
      return {
        data: newDataSoFar,
        scenario: scenario
      };
    };
  };

  var f = csv.open("output_sequential.csv");
  csv.writeLine(
    "participant_num,condition,beta,fairness_weight,comm_weight,w_other,round,action,p_alternation",
    f
  );

  var writeData = function (participant_num, condition, run_output) {
    mapN(function (i) {
      // console.log(run_output.alice_actions)
      // console.log(run_output)
      csv.writeLine(
        [participant_num,
          condition,
          params.beta,
          conditions[condition].fairness_cost,
          conditions[condition].comm_weight,
          0.5,
          i,
          run_output.data.actions[i],
          run_output.data.p_alternation[i],
        ].join(","),
        f
      );
    }, params.n_rounds + 1);
  };

  var simulate = function (participant_num, condition) {
  //   console.log(condition)
    var run_output = run("coffee", condition, {
      actions: ['other'],
      p_alternation: ['NA']
    });
  //   console.log(run_output)
    writeData(participant_num, condition, run_output);
  };

  var simulateAll = function (participants) {
      mapN(function (participant_num) {
          console.log("participant " + participant_num)
          map(function (condition) {
              simulate(participant_num, condition);
          }, condition_names);
      }, participants);
  }

  simulateAll(params.participants);

  csv.close(f)
}